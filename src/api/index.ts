/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * Furkan Boran
 * API documentation for Furkan Boran final year project
 * OpenAPI spec version: 1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import { getAxiosInstance } from './AxiosInstance';
export interface GenerateImageDto {
  /** Prompt to generate the image */
  prompt: string;
}

export interface GenerateImageResponse {
  /** Public URL of the generated image */
  imageURL: string;
  /** Prompt used to generate the image */
  prompt: string;
}

export interface ImageResponse {
  /** Public URL of the generated image */
  imageURL: string;
  /** Wallet address of the user who generated the image */
  createdBy: string;
  /** Prompt used to generate the image */
  prompt: string;
}

/**
 * User chain
 */
export type UserResponseChain = typeof UserResponseChain[keyof typeof UserResponseChain];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserResponseChain = {
  ETH: 'ETH',
  SOL: 'SOL',
  SUI: 'SUI',
} as const;

export interface UserResponse {
  /** User wallet address */
  walletAddress: string;
  /** User chain */
  chain: UserResponseChain;
  /** User creation date */
  createdAt: string;
  /** Last updated date */
  updatedAt: string;
}

export interface UserImageResponse {
  /** Image URL's that generated by the user */
  imageUrls: string[];
  /** The number of images generated by the user */
  count: number;
}

/**
 * Chain of the user
 */
export type VerifySignatureRequestDtoChain = typeof VerifySignatureRequestDtoChain[keyof typeof VerifySignatureRequestDtoChain];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const VerifySignatureRequestDtoChain = {
  ETH: 'ETH',
  SOL: 'SOL',
  SUI: 'SUI',
} as const;

export interface VerifySignatureRequestDto {
  /** Wallet address of the user */
  walletAddress: string;
  /** Nonce generated for the user */
  nonce: string;
  /** Signature by the user */
  signature: string;
  /** Chain of the user */
  chain: VerifySignatureRequestDtoChain;
}

export interface VerifySignatureResponse {
  /** JWT token for the user */
  authToken: string;
}

export interface AttributeDto {
  /** Trait type */
  trait_type: string;
  /** Trait value */
  value: string;
}

/**
 * Blockchain to create metadata for
 */
export type CreateNftMetadataDtoChain = typeof CreateNftMetadataDtoChain[keyof typeof CreateNftMetadataDtoChain];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateNftMetadataDtoChain = {
  ETH: 'ETH',
  SOL: 'SOL',
  SUI: 'SUI',
} as const;

export interface CreateNftMetadataDto {
  /** Blockchain to create metadata for */
  chain: CreateNftMetadataDtoChain;
  /** Name of the NFT */
  name: string;
  /** Description of the NFT */
  description: string;
  /** URL of the image (IPFS or HTTP) */
  imageUrl: string;
  /** Attributes/traits of the NFT */
  attributes: AttributeDto[];
  /** External URL for the NFT (optional) */
  externalUrl?: string;
}

/**
 * Blockchain the metadata was created for
 */
export type NftMetadataResponseChain = typeof NftMetadataResponseChain[keyof typeof NftMetadataResponseChain];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NftMetadataResponseChain = {
  ETH: 'ETH',
  SOL: 'SOL',
  SUI: 'SUI',
} as const;

export interface NftMetadataResponse {
  /** IPFS URL of the uploaded metadata */
  metadataUrl: string;
  /** HTTP gateway URL of the uploaded metadata for easier access */
  gatewayUrl: string;
  /** Blockchain the metadata was created for */
  chain: NftMetadataResponseChain;
}

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



export const appControllerGetHello = (
    
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<void>(
      {url: `/api`, method: 'GET', signal
    },
      options);
    }
  

export const getAppControllerGetHelloQueryKey = () => {
    return [`/api`] as const;
    }

    
export const getAppControllerGetHelloQueryOptions = <TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>>, request?: SecondParameter<typeof getAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAppControllerGetHelloQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof appControllerGetHello>>> = ({ signal }) => appControllerGetHello(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AppControllerGetHelloQueryResult = NonNullable<Awaited<ReturnType<typeof appControllerGetHello>>>
export type AppControllerGetHelloQueryError = unknown


export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof appControllerGetHello>>,
          TError,
          Awaited<ReturnType<typeof appControllerGetHello>>
        > , 'initialData'
      >, request?: SecondParameter<typeof getAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof appControllerGetHello>>,
          TError,
          Awaited<ReturnType<typeof appControllerGetHello>>
        > , 'initialData'
      >, request?: SecondParameter<typeof getAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>>, request?: SecondParameter<typeof getAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>>, request?: SecondParameter<typeof getAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAppControllerGetHelloQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const imageControllerGenerateAndUploadImage = (
    generateImageDto: GenerateImageDto,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<GenerateImageResponse>(
      {url: `/api/image/generate`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: generateImageDto, signal
    },
      options);
    }
  


export const getImageControllerGenerateAndUploadImageMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof imageControllerGenerateAndUploadImage>>, TError,{data: GenerateImageDto}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof imageControllerGenerateAndUploadImage>>, TError,{data: GenerateImageDto}, TContext> => {

const mutationKey = ['imageControllerGenerateAndUploadImage'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof imageControllerGenerateAndUploadImage>>, {data: GenerateImageDto}> = (props) => {
          const {data} = props ?? {};

          return  imageControllerGenerateAndUploadImage(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ImageControllerGenerateAndUploadImageMutationResult = NonNullable<Awaited<ReturnType<typeof imageControllerGenerateAndUploadImage>>>
    export type ImageControllerGenerateAndUploadImageMutationBody = GenerateImageDto
    export type ImageControllerGenerateAndUploadImageMutationError = unknown

    export const useImageControllerGenerateAndUploadImage = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof imageControllerGenerateAndUploadImage>>, TError,{data: GenerateImageDto}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof imageControllerGenerateAndUploadImage>>,
        TError,
        {data: GenerateImageDto},
        TContext
      > => {

      const mutationOptions = getImageControllerGenerateAndUploadImageMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const imageControllerGetRandomImages = (
    
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<ImageResponse[]>(
      {url: `/api/image/random-images`, method: 'GET', signal
    },
      options);
    }
  

export const getImageControllerGetRandomImagesQueryKey = () => {
    return [`/api/image/random-images`] as const;
    }

    
export const getImageControllerGetRandomImagesQueryOptions = <TData = Awaited<ReturnType<typeof imageControllerGetRandomImages>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imageControllerGetRandomImages>>, TError, TData>>, request?: SecondParameter<typeof getAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getImageControllerGetRandomImagesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof imageControllerGetRandomImages>>> = ({ signal }) => imageControllerGetRandomImages(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof imageControllerGetRandomImages>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ImageControllerGetRandomImagesQueryResult = NonNullable<Awaited<ReturnType<typeof imageControllerGetRandomImages>>>
export type ImageControllerGetRandomImagesQueryError = unknown


export function useImageControllerGetRandomImages<TData = Awaited<ReturnType<typeof imageControllerGetRandomImages>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof imageControllerGetRandomImages>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof imageControllerGetRandomImages>>,
          TError,
          Awaited<ReturnType<typeof imageControllerGetRandomImages>>
        > , 'initialData'
      >, request?: SecondParameter<typeof getAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useImageControllerGetRandomImages<TData = Awaited<ReturnType<typeof imageControllerGetRandomImages>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imageControllerGetRandomImages>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof imageControllerGetRandomImages>>,
          TError,
          Awaited<ReturnType<typeof imageControllerGetRandomImages>>
        > , 'initialData'
      >, request?: SecondParameter<typeof getAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useImageControllerGetRandomImages<TData = Awaited<ReturnType<typeof imageControllerGetRandomImages>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imageControllerGetRandomImages>>, TError, TData>>, request?: SecondParameter<typeof getAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useImageControllerGetRandomImages<TData = Awaited<ReturnType<typeof imageControllerGetRandomImages>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imageControllerGetRandomImages>>, TError, TData>>, request?: SecondParameter<typeof getAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getImageControllerGetRandomImagesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const imageControllerGetAllImages = (
    
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<ImageResponse[]>(
      {url: `/api/image/all-images`, method: 'GET', signal
    },
      options);
    }
  

export const getImageControllerGetAllImagesQueryKey = () => {
    return [`/api/image/all-images`] as const;
    }

    
export const getImageControllerGetAllImagesQueryOptions = <TData = Awaited<ReturnType<typeof imageControllerGetAllImages>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imageControllerGetAllImages>>, TError, TData>>, request?: SecondParameter<typeof getAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getImageControllerGetAllImagesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof imageControllerGetAllImages>>> = ({ signal }) => imageControllerGetAllImages(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof imageControllerGetAllImages>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ImageControllerGetAllImagesQueryResult = NonNullable<Awaited<ReturnType<typeof imageControllerGetAllImages>>>
export type ImageControllerGetAllImagesQueryError = unknown


export function useImageControllerGetAllImages<TData = Awaited<ReturnType<typeof imageControllerGetAllImages>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof imageControllerGetAllImages>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof imageControllerGetAllImages>>,
          TError,
          Awaited<ReturnType<typeof imageControllerGetAllImages>>
        > , 'initialData'
      >, request?: SecondParameter<typeof getAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useImageControllerGetAllImages<TData = Awaited<ReturnType<typeof imageControllerGetAllImages>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imageControllerGetAllImages>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof imageControllerGetAllImages>>,
          TError,
          Awaited<ReturnType<typeof imageControllerGetAllImages>>
        > , 'initialData'
      >, request?: SecondParameter<typeof getAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useImageControllerGetAllImages<TData = Awaited<ReturnType<typeof imageControllerGetAllImages>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imageControllerGetAllImages>>, TError, TData>>, request?: SecondParameter<typeof getAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useImageControllerGetAllImages<TData = Awaited<ReturnType<typeof imageControllerGetAllImages>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imageControllerGetAllImages>>, TError, TData>>, request?: SecondParameter<typeof getAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getImageControllerGetAllImagesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const userControllerGetMe = (
    
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<UserResponse>(
      {url: `/api/user/me`, method: 'GET', signal
    },
      options);
    }
  

export const getUserControllerGetMeQueryKey = () => {
    return [`/api/user/me`] as const;
    }

    
export const getUserControllerGetMeQueryOptions = <TData = Awaited<ReturnType<typeof userControllerGetMe>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerGetMe>>, TError, TData>>, request?: SecondParameter<typeof getAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUserControllerGetMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userControllerGetMe>>> = ({ signal }) => userControllerGetMe(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userControllerGetMe>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UserControllerGetMeQueryResult = NonNullable<Awaited<ReturnType<typeof userControllerGetMe>>>
export type UserControllerGetMeQueryError = unknown


export function useUserControllerGetMe<TData = Awaited<ReturnType<typeof userControllerGetMe>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerGetMe>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerGetMe>>,
          TError,
          Awaited<ReturnType<typeof userControllerGetMe>>
        > , 'initialData'
      >, request?: SecondParameter<typeof getAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserControllerGetMe<TData = Awaited<ReturnType<typeof userControllerGetMe>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerGetMe>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerGetMe>>,
          TError,
          Awaited<ReturnType<typeof userControllerGetMe>>
        > , 'initialData'
      >, request?: SecondParameter<typeof getAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserControllerGetMe<TData = Awaited<ReturnType<typeof userControllerGetMe>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerGetMe>>, TError, TData>>, request?: SecondParameter<typeof getAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useUserControllerGetMe<TData = Awaited<ReturnType<typeof userControllerGetMe>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerGetMe>>, TError, TData>>, request?: SecondParameter<typeof getAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserControllerGetMeQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const userControllerGetImages = (
    
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<UserImageResponse>(
      {url: `/api/user/me/images`, method: 'GET', signal
    },
      options);
    }
  

export const getUserControllerGetImagesQueryKey = () => {
    return [`/api/user/me/images`] as const;
    }

    
export const getUserControllerGetImagesQueryOptions = <TData = Awaited<ReturnType<typeof userControllerGetImages>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerGetImages>>, TError, TData>>, request?: SecondParameter<typeof getAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUserControllerGetImagesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userControllerGetImages>>> = ({ signal }) => userControllerGetImages(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userControllerGetImages>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UserControllerGetImagesQueryResult = NonNullable<Awaited<ReturnType<typeof userControllerGetImages>>>
export type UserControllerGetImagesQueryError = unknown


export function useUserControllerGetImages<TData = Awaited<ReturnType<typeof userControllerGetImages>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerGetImages>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerGetImages>>,
          TError,
          Awaited<ReturnType<typeof userControllerGetImages>>
        > , 'initialData'
      >, request?: SecondParameter<typeof getAxiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserControllerGetImages<TData = Awaited<ReturnType<typeof userControllerGetImages>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerGetImages>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerGetImages>>,
          TError,
          Awaited<ReturnType<typeof userControllerGetImages>>
        > , 'initialData'
      >, request?: SecondParameter<typeof getAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserControllerGetImages<TData = Awaited<ReturnType<typeof userControllerGetImages>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerGetImages>>, TError, TData>>, request?: SecondParameter<typeof getAxiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useUserControllerGetImages<TData = Awaited<ReturnType<typeof userControllerGetImages>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerGetImages>>, TError, TData>>, request?: SecondParameter<typeof getAxiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserControllerGetImagesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const authControllerVerifySignature = (
    verifySignatureRequestDto: VerifySignatureRequestDto,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<VerifySignatureResponse>(
      {url: `/api/auth/verify`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: verifySignatureRequestDto, signal
    },
      options);
    }
  


export const getAuthControllerVerifySignatureMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerVerifySignature>>, TError,{data: VerifySignatureRequestDto}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerVerifySignature>>, TError,{data: VerifySignatureRequestDto}, TContext> => {

const mutationKey = ['authControllerVerifySignature'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerVerifySignature>>, {data: VerifySignatureRequestDto}> = (props) => {
          const {data} = props ?? {};

          return  authControllerVerifySignature(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerVerifySignatureMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerVerifySignature>>>
    export type AuthControllerVerifySignatureMutationBody = VerifySignatureRequestDto
    export type AuthControllerVerifySignatureMutationError = unknown

    export const useAuthControllerVerifySignature = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerVerifySignature>>, TError,{data: VerifySignatureRequestDto}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerVerifySignature>>,
        TError,
        {data: VerifySignatureRequestDto},
        TContext
      > => {

      const mutationOptions = getAuthControllerVerifySignatureMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const nftControllerCreateNftMetadata = (
    createNftMetadataDto: CreateNftMetadataDto,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<NftMetadataResponse>(
      {url: `/api/nft/metadata`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createNftMetadataDto, signal
    },
      options);
    }
  


export const getNftControllerCreateNftMetadataMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof nftControllerCreateNftMetadata>>, TError,{data: CreateNftMetadataDto}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof nftControllerCreateNftMetadata>>, TError,{data: CreateNftMetadataDto}, TContext> => {

const mutationKey = ['nftControllerCreateNftMetadata'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof nftControllerCreateNftMetadata>>, {data: CreateNftMetadataDto}> = (props) => {
          const {data} = props ?? {};

          return  nftControllerCreateNftMetadata(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type NftControllerCreateNftMetadataMutationResult = NonNullable<Awaited<ReturnType<typeof nftControllerCreateNftMetadata>>>
    export type NftControllerCreateNftMetadataMutationBody = CreateNftMetadataDto
    export type NftControllerCreateNftMetadataMutationError = unknown

    export const useNftControllerCreateNftMetadata = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof nftControllerCreateNftMetadata>>, TError,{data: CreateNftMetadataDto}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof nftControllerCreateNftMetadata>>,
        TError,
        {data: CreateNftMetadataDto},
        TContext
      > => {

      const mutationOptions = getNftControllerCreateNftMetadataMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
